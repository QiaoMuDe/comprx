# GZIP内存数据压缩函数实现方案

## 1. 总体架构设计

### 1.1 分层架构
```
主包 (comprx.go)
├── GzipBytes()     - 暴露给用户的字节压缩API
├── UngzipBytes()   - 暴露给用户的字节解压API  
├── GzipString()    - 暴露给用户的字符串压缩API
└── UngzipString()  - 暴露给用户的字符串解压API

内部包 (internal/gzip/)
├── CompressBytes() - 内部字节压缩实现
├── DecompressBytes() - 内部字节解压实现
├── CompressString() - 内部字符串压缩实现
└── DecompressString() - 内部字符串解压实现
```

### 1.2 设计原则
- **职责分离**: 主包负责API暴露，内部包负责具体实现
- **复用现有**: 最大化复用现有的配置系统和工具函数
- **性能优化**: 使用缓冲区池和流式处理
- **错误一致**: 保持与现有API一致的错误处理风格

## 2. 内部实现方案 (internal/gzip/)

### 2.1 新增文件: memory.go
```go
package cxgzip

import (
    "bytes"
    "compress/gzip"
    "fmt"
    "io"
    "strings"
    
    "gitee.com/MM-Q/comprx/config"
    "gitee.com/MM-Q/comprx/internal/utils"
)

// CompressBytes 压缩字节数据到内存
func CompressBytes(data []byte, level config.CompressionLevel) ([]byte, error)

// DecompressBytes 从内存解压字节数据
func DecompressBytes(compressedData []byte) ([]byte, error)

// CompressString 压缩字符串到内存
func CompressString(text string, level config.CompressionLevel) ([]byte, error)

// DecompressString 从内存解压为字符串
func DecompressString(compressedData []byte) (string, error)
```

### 2.2 核心实现逻辑

#### 2.2.1 CompressBytes 实现
```go
func CompressBytes(data []byte, level config.CompressionLevel) ([]byte, error) {
    // 1. 参数验证
    if data == nil {
        return nil, fmt.Errorf("输入数据不能为nil")
    }
    
    // 2. 创建内存缓冲区
    var buf bytes.Buffer
    
    // 3. 创建gzip写入器
    writer, err := gzip.NewWriterLevel(&buf, config.GetCompressionLevel(&config.Config{
        CompressionLevel: level,
    }))
    if err != nil {
        return nil, fmt.Errorf("创建gzip写入器失败: %w", err)
    }
    defer writer.Close()
    
    // 4. 使用32KB缓冲区和CopyBuffer进行数据传输
    reader := bytes.NewReader(data)
    buffer := utils.GetBuffer(32 * 1024) // 使用32KB缓冲区
    defer utils.PutBuffer(buffer)
    
    if _, err := io.CopyBuffer(writer, reader, buffer); err != nil {
        return nil, fmt.Errorf("压缩数据失败: %w", err)
    }
    
    // 5. 关闭写入器确保数据完整写入
    if err := writer.Close(); err != nil {
        return nil, fmt.Errorf("完成压缩失败: %w", err)
    }
    
    return buf.Bytes(), nil
}
```

#### 2.2.2 DecompressBytes 实现
```go
func DecompressBytes(compressedData []byte) ([]byte, error) {
    // 1. 参数验证
    if compressedData == nil || len(compressedData) == 0 {
        return nil, fmt.Errorf("压缩数据不能为空")
    }
    
    // 2. 创建字节读取器
    reader := bytes.NewReader(compressedData)
    
    // 3. 创建gzip读取器
    gzipReader, err := gzip.NewReader(reader)
    if err != nil {
        return nil, fmt.Errorf("创建gzip读取器失败: %w", err)
    }
    defer gzipReader.Close()
    
    // 4. 使用32KB缓冲区和CopyBuffer读取解压数据
    var buf bytes.Buffer
    buffer := utils.GetBuffer(32 * 1024) // 使用32KB缓冲区
    defer utils.PutBuffer(buffer)
    
    if _, err := io.CopyBuffer(&buf, gzipReader, buffer); err != nil {
        return nil, fmt.Errorf("解压数据失败: %w", err)
    }
    
    return buf.Bytes(), nil
}
```

#### 2.2.3 CompressString 实现
```go
func CompressString(text string, level config.CompressionLevel) ([]byte, error) {
    // 直接复用CompressBytes
    return CompressBytes([]byte(text), level)
}
```

#### 2.2.4 DecompressString 实现
```go
func DecompressString(compressedData []byte) (string, error) {
    // 1. 先解压为字节
    decompressed, err := DecompressBytes(compressedData)
    if err != nil {
        return "", err
    }
    
    // 2. 转换为字符串
    return string(decompressed), nil
}
```

### 2.3 新增文件: memory_test.go
```go
package cxgzip

import (
    "testing"
    "gitee.com/MM-Q/comprx/config"
)

// 测试用例包括:
// - 基本压缩解压功能
// - 空数据处理
// - 大数据处理
// - 不同压缩级别
// - 错误情况处理
// - 性能基准测试
```

## 3. 主包API暴露 (comprx.go)

### 3.1 新增API函数
```go
// GzipBytes 压缩字节数据
//
// 参数:
//   - data: 要压缩的字节数据
//   - level: 压缩级别
//
// 返回:
//   - []byte: 压缩后的数据
//   - error: 错误信息
//
// 使用示例:
//   compressed, err := GzipBytes([]byte("hello world"), config.CompressionLevelDefault)
func GzipBytes(data []byte, level config.CompressionLevel) ([]byte, error) {
    return gzip.CompressBytes(data, level)
}

// UngzipBytes 解压字节数据
//
// 参数:
//   - compressedData: 压缩的字节数据
//
// 返回:
//   - []byte: 解压后的数据
//   - error: 错误信息
//
// 使用示例:
//   decompressed, err := UngzipBytes(compressedData)
func UngzipBytes(compressedData []byte) ([]byte, error) {
    return gzip.DecompressBytes(compressedData)
}

// GzipString 压缩字符串
//
// 参数:
//   - text: 要压缩的字符串
//   - level: 压缩级别
//
// 返回:
//   - []byte: 压缩后的数据
//   - error: 错误信息
//
// 使用示例:
//   compressed, err := GzipString("hello world", config.CompressionLevelBest)
func GzipString(text string, level config.CompressionLevel) ([]byte, error) {
    return gzip.CompressString(text, level)
}

// UngzipString 解压为字符串
//
// 参数:
//   - compressedData: 压缩的字节数据
//
// 返回:
//   - string: 解压后的字符串
//   - error: 错误信息
//
// 使用示例:
//   text, err := UngzipString(compressedData)
func UngzipString(compressedData []byte) (string, error) {
    return gzip.DecompressString(compressedData)
}
```

## 4. 性能优化策略

### 4.1 内存管理优化
```go
// 使用缓冲区池减少内存分配
var (
    bufferPool = sync.Pool{
        New: func() interface{} {
            return make([]byte, 32*1024) // 32KB缓冲区
        },
    }
)

// 优化版本的压缩函数
func CompressBytesOptimized(data []byte, level config.CompressionLevel) ([]byte, error) {
    // 使用预分配的缓冲区
    buf := bytes.NewBuffer(make([]byte, 0, len(data)/2)) // 预估压缩后大小
    
    // 其他实现...
}
```

### 4.2 流式处理优化
```go
// 对于大数据，使用流式处理避免内存峰值
func CompressLargeData(data []byte, level config.CompressionLevel) ([]byte, error) {
    if len(data) > 10*1024*1024 { // 10MB以上使用流式处理
        return compressStream(data, level)
    }
    return CompressBytes(data, level)
}
```

## 5. 错误处理策略

### 5.1 错误类型定义
```go
var (
    ErrEmptyData     = fmt.Errorf("数据不能为空")
    ErrInvalidGzip   = fmt.Errorf("无效的gzip数据")
    ErrCompressionFailed = fmt.Errorf("压缩失败")
    ErrDecompressionFailed = fmt.Errorf("解压失败")
)
```

### 5.2 统一错误格式
- 所有错误信息使用中文
- 错误信息包含具体的失败原因
- 使用fmt.Errorf包装底层错误

## 6. 测试策略

### 6.1 单元测试覆盖
- 基本功能测试 (正常压缩解压)
- 边界条件测试 (空数据、大数据)
- 错误情况测试 (无效数据、损坏数据)
- 压缩级别测试 (不同压缩级别的效果)

### 6.2 性能测试
- 小数据压缩性能 (< 1KB)
- 中等数据压缩性能 (1KB - 1MB)
- 大数据压缩性能 (> 1MB)
- 内存使用情况测试

### 6.3 集成测试
- 与现有文件API的兼容性
- 压缩数据的跨平台兼容性

## 7. 实施步骤

### 第一阶段: 基础实现
1. 创建 `internal/gzip/memory.go`
2. 实现基础的4个内部函数
3. 创建对应的单元测试

### 第二阶段: 主包集成
1. 在 `comprx.go` 中添加4个公开API
2. 添加完整的文档注释
3. 创建使用示例

### 第三阶段: 优化完善
1. 性能优化 (缓冲区池等)
2. 错误处理完善
3. 边界情况处理

### 第四阶段: 测试验证
1. 完整的测试覆盖
2. 性能基准测试
3. 文档和示例完善

## 8. 兼容性考虑

### 8.1 向后兼容
- 新API不影响现有文件级API
- 保持现有配置系统不变
- 错误处理风格保持一致

### 8.2 扩展性
- 预留接口供未来添加更多压缩选项
- 支持自定义缓冲区大小
- 支持压缩进度回调 (可选)

## 9. 文档和示例

### 9.1 API文档
- 每个函数都有完整的注释
- 包含参数说明和返回值说明
- 提供使用示例

### 9.2 使用示例
```go
// 基本使用
data := []byte("Hello, World!")
compressed, err := comprx.GzipBytes(data, config.CompressionLevelDefault)
if err != nil {
    log.Fatal(err)
}

decompressed, err := comprx.UngzipBytes(compressed)
if err != nil {
    log.Fatal(err)
}

// 字符串压缩
text := "这是一个测试字符串"
compressed, err = comprx.GzipString(text, config.CompressionLevelBest)
if err != nil {
    log.Fatal(err)
}

result, err := comprx.UngzipString(compressed)
if err != nil {
    log.Fatal(err)
}
```

这个实现方案充分利用了现有的架构和工具，同时保持了API的简洁性和一致性。通过分层设计，既满足了内部实现的灵活性，又为用户提供了简单易用的接口。