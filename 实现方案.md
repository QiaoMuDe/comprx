# 过滤和排除功能实现方案

## 1. 功能需求分析

### 核心功能
- **包含模式 (Include)**: 只压缩匹配指定模式的文件
- **排除模式 (Exclude)**: 排除匹配指定模式的文件
- **文件大小过滤**: 根据文件大小范围过滤文件

### 优先级处理逻辑
1. 首先应用 Include 模式（如果指定）
2. 然后应用 Exclude 模式
3. 文件大小过滤贯穿整个过程

### 设计原则
- **简洁性**: 避免功能重复，保持API简洁
- **灵活性**: 支持编程式动态过滤规则
- **性能**: 在文件遍历阶段早期过滤，提升性能

## 2. 现有代码架构分析

### 当前压缩流程
```
comprx.go (API层) 
  ↓
internal/core/comprx.go (核心逻辑)
  ↓
internal/cx*/xxx.go (具体格式实现)
  ↓
filepath.WalkDir() (文件遍历)
```

### 关键插入点
1. **Options结构扩展**: 在 `options.go` 中添加 FilterOptions
2. **Config结构扩展**: 在 `config/config.go` 中添加过滤配置
3. **文件遍历过滤**: 在各个格式的 walkDirectory 函数中集成过滤逻辑
4. **工具函数**: 在 `internal/utils/` 中添加过滤相关工具函数

## 3. 详细实现方案

### 3.1 数据结构设计

#### FilterOptions 结构定义
```go
// 在 options.go 中添加
type FilterOptions struct {
    Include []string // 包含模式，支持 glob 语法
    Exclude []string // 排除模式，支持 glob 语法
    MaxSize int64    // 最大文件大小（字节），0 表示无限制
    MinSize int64    // 最小文件大小（字节），默认为 0
}

// 扩展现有 Options 结构
type Options struct {
    CompressionLevel      types.CompressionLevel
    OverwriteExisting     bool
    ProgressEnabled       bool
    ProgressStyle         types.ProgressStyle
    DisablePathValidation bool
    Filter                FilterOptions // 新增过滤选项
}
```

#### Config 结构扩展
```go
// 在 config/config.go 中扩展
type Config struct {
    CompressionLevel      types.CompressionLevel
    OverwriteExisting     bool
    Progress              *progress.Progress
    DisablePathValidation bool
    Filter                *FilterConfig // 新增过滤配置
}

type FilterConfig struct {
    IncludePatterns []string
    ExcludePatterns []string
    MaxSize         int64
    MinSize         int64
}
```

### 3.2 核心过滤逻辑

#### 过滤器接口设计
```go
// 在 internal/utils/filter.go 中定义
type FileFilter interface {
    ShouldInclude(path string, info os.FileInfo) bool
}

type CompositeFilter struct {
    includePatterns []string
    excludePatterns []string
    maxSize         int64
    minSize         int64
}

func (f *CompositeFilter) ShouldInclude(path string, info os.FileInfo) bool {
    // 实现过滤逻辑
    // 1. 检查文件大小
    // 2. 检查包含模式
    // 3. 检查排除模式
}
```

### 3.3 集成点分析

#### 3.3.1 API 层集成 (comprx.go)
```go
// 扩展现有函数，保持向后兼容
func PackWithFilter(dst string, src string, filter FilterOptions) error {
    opts := DefaultOptions()
    opts.Filter = filter
    return PackOptions(dst, src, opts)
}

// 或者通过 Options 传递
func PackOptions(dst string, src string, opts Options) error {
    comprx := core.New().
        WithCompressionLevel(opts.CompressionLevel).
        WithOverwriteExisting(opts.OverwriteExisting).
        WithProgressAndStyle(opts.ProgressEnabled, opts.ProgressStyle).
        WithDisablePathValidation(opts.DisablePathValidation).
        WithFilter(opts.Filter) // 新增过滤配置
    
    return comprx.Pack(dst, src)
}
```

#### 3.3.2 核心层集成 (internal/core/comprx.go)
```go
// 扩展 Comprx 结构
type Comprx struct {
    Config *config.Config
}

// 添加过滤配置方法
func (c *Comprx) WithFilter(filter FilterOptions) *Comprx {
    c.Config.Filter = &config.FilterConfig{
        IncludePatterns: filter.Include,
        ExcludePatterns: filter.Exclude,
        MaxSize:         filter.MaxSize,
        MinSize:         filter.MinSize,
    }
    
    return c
}
```

#### 3.3.3 格式实现层集成

以 ZIP 为例 (internal/cxzip/zip.go):
```go
// 修改 walkDirectoryForZip 函数
func walkDirectoryForZip(src string, zipWriter *zip.Writer, cfg *config.Config) error {
    // 创建过滤器
    filter := createFileFilter(cfg.Filter)
    
    return filepath.WalkDir(src, func(path string, entry fs.DirEntry, err error) error {
        if err != nil {
            if os.IsNotExist(err) {
                return nil
            }
            return fmt.Errorf("遍历路径 '%s' 时出错: %w", path, err)
        }

        // 获取文件信息
        info, err := entry.Info()
        if err != nil {
            return fmt.Errorf("获取文件信息失败 '%s': %w", path, err)
        }

        // 应用过滤器
        if filter != nil && !filter.ShouldInclude(path, info) {
            if info.IsDir() {
                return filepath.SkipDir // 跳过整个目录
            }
            return nil // 跳过文件
        }

        // 获取相对路径
        headerName, err := filepath.Rel(filepath.Dir(src), path)
        if err != nil {
            return fmt.Errorf("处理路径 '%s' 时出错 - 获取相对路径失败: %w", path, err)
        }

        headerName = filepath.ToSlash(headerName)

        // 根据文件类型处理（现有逻辑）
        switch {
        case entry.Type().IsRegular():
            cfg.Progress.Adding(headerName)
            return processRegularFile(zipWriter, path, headerName, info, cfg)
        case entry.IsDir():
            cfg.Progress.Storing(headerName)
            return processDirectory(zipWriter, headerName, info)
        // ... 其他文件类型处理
        }
    })
}

// 创建过滤器的辅助函数
func createFileFilter(filterConfig *config.FilterConfig) utils.FileFilter {
    if filterConfig == nil {
        return nil
    }
    
    return &utils.CompositeFilter{
        IncludePatterns: filterConfig.IncludePatterns,
        ExcludePatterns: filterConfig.ExcludePatterns,
        MaxSize:         filterConfig.MaxSize,
        MinSize:         filterConfig.MinSize,
    }
}
```

### 3.4 工具函数实现

#### 3.4.1 模式匹配 (internal/utils/pattern.go)
```go
import "path/filepath"

// MatchPattern 检查路径是否匹配模式
func MatchPattern(pattern, path string) bool {
    // 使用 filepath.Match 进行基础匹配
    matched, err := filepath.Match(pattern, filepath.Base(path))
    if err == nil && matched {
        return true
    }
    
    // 支持路径匹配
    matched, err = filepath.Match(pattern, path)
    if err == nil && matched {
        return true
    }
    
    // 支持目录匹配
    dir := filepath.Dir(path)
    matched, err = filepath.Match(pattern, dir)
    return err == nil && matched
}

// MatchAnyPattern 检查路径是否匹配任一模式
func MatchAnyPattern(patterns []string, path string) bool {
    for _, pattern := range patterns {
        if MatchPattern(pattern, path) {
            return true
        }
    }
    return false
}
```

#### 3.4.2 文件大小过滤 (internal/utils/size_filter.go)
```go
// CheckSizeFilter 检查文件大小是否符合过滤条件
func CheckSizeFilter(info os.FileInfo, minSize, maxSize int64) bool {
    if info.IsDir() {
        return true // 目录总是通过大小过滤
    }
    
    size := info.Size()
    
    // 检查最小大小
    if minSize > 0 && size < minSize {
        return false
    }
    
    // 检查最大大小
    if maxSize > 0 && size > maxSize {
        return false
    }
    
    return true
}
```

### 3.5 过滤逻辑实现

#### 核心过滤算法
```go
// 在 internal/utils/filter.go 中实现
func (f *CompositeFilter) ShouldInclude(path string, info os.FileInfo) bool {
    // 1. 文件大小过滤
    if !f.checkSizeFilter(info) {
        return false
    }
    
    // 2. 包含模式检查（如果指定了包含模式）
    if len(f.includePatterns) > 0 {
        if !f.matchAnyPattern(f.includePatterns, path) {
            return false
        }
    }
    
    // 3. 排除模式检查
    if len(f.excludePatterns) > 0 {
        if f.matchAnyPattern(f.excludePatterns, path) {
            return false
        }
    }
    
    return true
}

func (f *CompositeFilter) checkSizeFilter(info os.FileInfo) bool {
    if info.IsDir() {
        return true // 目录总是通过大小过滤
    }
    
    size := info.Size()
    
    if f.minSize > 0 && size < f.minSize {
        return false
    }
    
    if f.maxSize > 0 && size > f.maxSize {
        return false
    }
    
    return true
}

func (f *CompositeFilter) matchAnyPattern(patterns []string, path string) bool {
    for _, pattern := range patterns {
        if matched, _ := filepath.Match(pattern, filepath.Base(path)); matched {
            return true
        }
        if matched, _ := filepath.Match(pattern, path); matched {
            return true
        }
    }
    return false
}
```

## 4. 实施步骤

### 第一阶段：基础结构
1. 扩展 `Options` 和 `Config` 结构
2. 实现基础的模式匹配功能
3. 实现文件大小过滤

### 第二阶段：核心集成
1. 在各个压缩格式中集成过滤逻辑
2. 添加相关的配置方法
3. 实现过滤器的性能优化

### 第三阶段：测试和优化
1. 编写单元测试
2. 编写集成测试
3. 性能优化和错误处理完善

### 第四阶段：文档和示例
1. 更新 README.md
2. 添加使用示例
3. 编写 .comprxignore 语法文档

## 5. 使用示例

### 基础过滤
```go
filter := comprx.FilterOptions{
    Include: []string{"*.go", "*.md"},
    Exclude: []string{"*_test.go", "vendor/*"},
    MaxSize: 10 * 1024 * 1024, // 10MB
    MinSize: 1024,              // 1KB
}

err := comprx.PackWithFilter("output.zip", "src/", filter)
```

### 复合过滤
```go
filter := comprx.FilterOptions{
    Include: []string{"src/*", "docs/*"},
    Exclude: []string{"*.tmp", "*.log"},
    MaxSize: 50 * 1024 * 1024, // 50MB
}

err := comprx.PackWithFilter("project.tar.gz", "./", filter)
```

### 辅助函数：从忽略文件加载排除模式

为了方便用户使用类似 `.gitignore` 的文件来管理排除规则，我们提供一个辅助函数：

```go
// LoadExcludeFromFile 从忽略文件加载排除模式
//
// 参数:
//   - ignoreFilePath: 忽略文件路径（如 ".comprxignore", ".gitignore"）
//
// 返回:
//   - []string: 排除模式列表
//   - error: 错误信息
//
// 支持的文件格式:
//   - 每行一个模式
//   - 支持 # 开头的注释行
//   - 自动忽略空行
//   - 支持 glob 模式匹配
//
// 使用示例:
//   patterns, err := comprx.LoadExcludeFromFile(".comprxignore")
func LoadExcludeFromFile(ignoreFilePath string) ([]string, error) {
    file, err := os.Open(ignoreFilePath)
    if err != nil {
        if os.IsNotExist(err) {
            return nil, fmt.Errorf("忽略文件不存在: %s", ignoreFilePath)
        }
        return nil, fmt.Errorf("打开忽略文件失败: %w", err)
    }
    defer file.Close()

    var patterns []string
    scanner := bufio.NewScanner(file)
    lineNum := 0
    
    for scanner.Scan() {
        lineNum++
        line := strings.TrimSpace(scanner.Text())
        
        // 跳过空行和注释行
        if line == "" || strings.HasPrefix(line, "#") {
            continue
        }
        
        // 验证模式是否有效
        if _, err := filepath.Match(line, "test"); err != nil {
            return nil, fmt.Errorf("第 %d 行包含无效的 glob 模式 '%s': %w", lineNum, line, err)
        }
        
        patterns = append(patterns, line)
    }
    
    if err := scanner.Err(); err != nil {
        return nil, fmt.Errorf("读取忽略文件失败: %w", err)
    }
    
    return patterns, nil
}

// LoadExcludeFromFileOrEmpty 从忽略文件加载排除模式，文件不存在时返回空列表
//
// 参数:
//   - ignoreFilePath: 忽略文件路径
//
// 返回:
//   - []string: 排除模式列表，文件不存在时返回空列表
//   - error: 错误信息（文件不存在不算错误）
//
// 使用示例:
//   patterns, err := comprx.LoadExcludeFromFileOrEmpty(".comprxignore")
func LoadExcludeFromFileOrEmpty(ignoreFilePath string) ([]string, error) {
    patterns, err := LoadExcludeFromFile(ignoreFilePath)
    if err != nil {
        if os.IsNotExist(err) {
            return []string{}, nil // 文件不存在返回空列表，不是错误
        }
        return nil, err
    }
    return patterns, nil
}
```

### 使用示例

#### 基本使用
```go
// 从 .comprxignore 文件加载排除规则
excludePatterns, err := comprx.LoadExcludeFromFile(".comprxignore")
if err != nil {
    return fmt.Errorf("加载忽略文件失败: %w", err)
}

filter := comprx.FilterOptions{
    Exclude: excludePatterns,
    MaxSize: 10 * 1024 * 1024, // 10MB
}

err = comprx.PackWithFilter("output.zip", "src/", filter)
```

#### 结合手动排除规则
```go
// 从文件加载基础排除规则
filePatterns, err := comprx.LoadExcludeFromFileOrEmpty(".comprxignore")
if err != nil {
    return err
}

// 添加额外的排除规则
allExcludePatterns := append(filePatterns, "*.tmp", "debug.log")

filter := comprx.FilterOptions{
    Include: []string{"*.go", "*.md"},
    Exclude: allExcludePatterns,
    MaxSize: 50 * 1024 * 1024, // 50MB
}

err = comprx.PackWithFilter("project.tar.gz", "./", filter)
```

#### 支持多种忽略文件
```go
// 尝试加载多种忽略文件
var excludePatterns []string

// 尝试 .comprxignore
if patterns, err := comprx.LoadExcludeFromFileOrEmpty(".comprxignore"); err == nil {
    excludePatterns = append(excludePatterns, patterns...)
}

// 尝试 .gitignore
if patterns, err := comprx.LoadExcludeFromFileOrEmpty(".gitignore"); err == nil {
    excludePatterns = append(excludePatterns, patterns...)
}

filter := comprx.FilterOptions{
    Exclude: excludePatterns,
}

err := comprx.PackWithFilter("backup.zip", "./", filter)
```

### .comprxignore 文件格式示例

```
# ComprX 忽略文件示例
# 支持 glob 模式匹配

# 临时文件
*.tmp
*.temp
*~

# 日志文件
*.log
logs/

# 构建产物
dist/
build/
target/
*.exe
*.dll

# 依赖目录
node_modules/
vendor/
.git/

# IDE 文件
.vscode/
.idea/
*.swp

# 系统文件
.DS_Store
Thumbs.db

# 大文件（超过100MB的文件通常不需要压缩）
# 注意：这里只是示例，实际大小过滤通过 MaxSize 参数控制
```

## 6. 注意事项

### 性能考虑
- 模式匹配可能影响性能，需要优化匹配算法
- 大目录遍历时，早期过滤可以提升性能
- 考虑缓存编译后的正则表达式

### 兼容性
- 保持现有 API 的向后兼容性
- 新功能通过可选参数提供
- 默认行为不变

### 错误处理
- 模式匹配错误需要清晰的错误信息
- 提供调试模式显示过滤决策过程
- 无效的过滤模式应该给出友好的错误提示

## 7. 扩展可能性

### 未来增强
- 支持正则表达式模式
- 支持基于文件内容的过滤
- 支持基于文件修改时间的过滤
- 支持更复杂的 glob 模式（如 `**` 递归匹配）
- 支持忽略文件功能（通过辅助函数实现）
- 支持全局和项目级配置文件

### 如果需要忽略文件功能
虽然核心API不包含忽略文件功能，但可以通过以下方式实现：

1. **辅助函数方式**: 提供 `LoadExcludeFromFile()` 函数
2. **第三方包装**: 用户可以自己实现忽略文件解析
3. **未来扩展**: 如果用户需求强烈，可以在后续版本中添加

这种设计既保持了核心API的简洁性，又为有特殊需求的用户提供了扩展能力。
