# ZLIB 格式实现方案

## 📋 项目概述

基于现有 comprx 项目架构，新增 ZLIB 压缩格式支持。遵循项目现有的设计模式和代码结构，确保与现有功能的一致性和兼容性。

## 🏗️ 实现架构

### 现有架构分析
- **子包命名规范**: `cx` + 格式名（如 `cxgzip`, `cxzip`）
- **功能模块划分**: 每个子包包含压缩、解压、内存操作、列表功能
- **配置统一管理**: 通过 `internal/config` 统一管理配置
- **核心集成**: 通过 `internal/core` 进行格式路由和统一调用

### 新增子包结构
```
internal/
└── cxzlib/          # ZLIB 压缩格式实现
    ├── zlib.go      # 单文件压缩（类似 gzip.go）
    ├── unzlib.go    # 单文件解压
    ├── memory.go    # 内存压缩/解压和流式处理
    ├── list.go      # 文件列表功能
    └── *_test.go    # 对应测试文件
```

## 🎯 实现阶段规划

### 阶段一：类型定义和基础架构
1. **扩展 types/types.go**
   - 添加 ZLIB 压缩格式常量
   - 更新格式检测函数
   - 更新支持格式列表

2. **更新配置系统**
   - 确保 ZLIB 格式支持现有压缩级别
   - 验证配置兼容性

### 阶段二：ZLIB 子包实现
1. **创建 internal/cxzlib/ 目录**
2. **实现核心功能文件**：
   - `zlib.go` - 单文件压缩
   - `unzlib.go` - 单文件解压
   - `memory.go` - 内存操作和流式处理
   - `list.go` - 文件列表功能
3. **编写完整测试用例**

### 阶段三：核心集成
1. **更新 internal/core/comprx.go**
   - 添加 ZLIB 格式的路由逻辑
   - 集成到统一的压缩/解压接口
2. **更新主包 API**
   - 扩展 comprx.go 中的便捷函数
   - 添加 ZLIB 格式的内存和流式 API

### 阶段四：测试和文档
1. **集成测试**
2. **性能测试**
3. **更新 README.md**
4. **API 文档完善**


## 📝 详细实现规范

### ZLIB 子包实现细节

#### 1. zlib.go - 单文件压缩
```go
package cxzlib

import (
    "compress/zlib"
    "fmt"
    "os"
    "path/filepath"
    
    "gitee.com/MM-Q/comprx/internal/config"
    "gitee.com/MM-Q/comprx/internal/utils"
)

// Zlib 压缩单个文件为ZLIB格式
func Zlib(dst string, src string, cfg *config.Config) error {
    // 实现逻辑参考 cxgzip/gzip.go
    // 1. 路径验证和绝对路径转换
    // 2. 源文件检查（必须是文件，不能是目录）
    // 3. 目标文件覆盖检查
    // 4. 进度条初始化
    // 5. 创建 zlib 写入器
    // 6. 流式复制数据
    // 7. 资源清理
}
```

#### 2. unzlib.go - 单文件解压
```go
package cxzlib

// Unzlib 解压ZLIB文件
func Unzlib(src string, dst string, cfg *config.Config) error {
    // 实现逻辑参考 cxgzip/ungzip.go
    // 1. 路径验证
    // 2. 源文件检查
    // 3. 目标路径处理
    // 4. 进度条初始化
    // 5. 创建 zlib 读取器
    // 6. 流式解压数据
    // 7. 资源清理
}
```

#### 3. memory.go - 内存操作和流式处理
```go
package cxzlib

import (
    "bytes"
    "compress/zlib"
    "io"
    
    "gitee.com/MM-Q/comprx/internal/config"
    "gitee.com/MM-Q/comprx/types"
)

// CompressBytes 压缩字节数据到内存
func CompressBytes(data []byte, level types.CompressionLevel) ([]byte, error) {
    // 参考 cxgzip/memory.go 的实现模式
}

// DecompressBytes 从内存解压字节数据
func DecompressBytes(compressedData []byte) ([]byte, error) {
    // 参考 cxgzip/memory.go 的实现模式
}

// CompressString 压缩字符串到内存
func CompressString(text string, level types.CompressionLevel) ([]byte, error) {
    // 复用 CompressBytes
}

// DecompressString 从内存解压为字符串
func DecompressString(compressedData []byte) (string, error) {
    // 复用 DecompressBytes
}

// CompressStream 流式压缩数据
func CompressStream(dst io.Writer, src io.Reader, level types.CompressionLevel) error {
    // 参考 cxgzip/memory.go 的流式实现
}

// DecompressStream 流式解压数据
func DecompressStream(dst io.Writer, src io.Reader) error {
    // 参考 cxgzip/memory.go 的流式实现
}
```

#### 4. list.go - 文件列表功能
```go
package cxzlib

import (
    "gitee.com/MM-Q/comprx/types"
)

// List 列出ZLIB文件信息
func List(zlibPath string, limit int, pattern string) (*types.ArchiveInfo, error) {
    // ZLIB 是单文件压缩，类似 GZIP
    // 返回单个文件的信息
    // 参考 cxgzip/list.go 的实现
}
```

### DEFLATE 子包实现细节

#### 1. deflate.go - 压缩实现
```go
package cxdeflate

import (
    "compress/flate"
    "io"
    
    "gitee.com/MM-Q/comprx/internal/config"
    "gitee.com/MM-Q/comprx/types"
)

// CompressBytes 压缩字节数据
func CompressBytes(data []byte, level types.CompressionLevel) ([]byte, error) {
    // 使用 flate.NewWriter 实现
}

// CompressStream 流式压缩
func CompressStream(dst io.Writer, src io.Reader, level types.CompressionLevel) error {
    // 使用 flate.NewWriter 实现流式压缩
}
```

#### 2. inflate.go - 解压实现
```go
package cxdeflate

import (
    "compress/flate"
    "io"
)

// DecompressBytes 解压字节数据
func DecompressBytes(compressedData []byte) ([]byte, error) {
    // 使用 flate.NewReader 实现
}

// DecompressStream 流式解压
func DecompressStream(dst io.Writer, src io.Reader) error {
    // 使用 flate.NewReader 实现流式解压
}
```

#### 3. memory.go - 内存和流式处理
```go
package cxdeflate

// 整合压缩和解压的内存操作
// 提供字符串压缩/解压接口
// 参考 cxgzip/memory.go 的完整实现模式
```

### 类型定义扩展

#### types/types.go 扩展
```go
const (
    // 现有格式...
    CompressTypeZlib   CompressType = ".zlib"    // ZLIB 压缩格式
    CompressTypeDeflate CompressType = ".deflate" // DEFLATE 压缩格式
)

// 更新 supportedCompressTypes map
var supportedCompressTypes = map[CompressType]struct{}{
    // 现有格式...
    CompressTypeZlib:   {}, // ZLIB 压缩格式
    CompressTypeDeflate: {}, // DEFLATE 压缩格式
}

// 更新 DetectCompressFormat 函数
func DetectCompressFormat(filename string) (CompressType, error) {
    // 添加对 .zlib 和 .deflate 扩展名的支持
}
```

### 核心集成更新

#### internal/core/comprx.go 扩展
```go
// 在 Pack 方法中添加新格式支持
func (c *Comprx) Pack(dst string, src string) error {
    format, err := types.DetectCompressFormat(dst)
    if err != nil {
        return err
    }

    switch format {
    // 现有格式处理...
    case types.CompressTypeZlib:
        return cxzlib.Zlib(dst, src, c.Config)
    }
}

// 在 Unpack 方法中添加新格式支持
func (c *Comprx) Unpack(src string, dst string) error {
    format, err := types.DetectCompressFormat(src)
    if err != nil {
        return err
    }

    switch format {
    // 现有格式处理...
    case types.CompressTypeZlib:
        return cxzlib.Unzlib(src, dst, c.Config)
    }
}
```

#### comprx.go 主包 API 扩展
```go
// ==================== ZLIB 内存压缩API ====================

// ZlibBytes 压缩字节数据
func ZlibBytes(data []byte, level types.CompressionLevel) ([]byte, error) {
    return cxzlib.CompressBytes(data, level)
}

// UnzlibBytes 解压字节数据
func UnzlibBytes(compressedData []byte) ([]byte, error) {
    return cxzlib.DecompressBytes(compressedData)
}

// ZlibString 压缩字符串
func ZlibString(text string, level types.CompressionLevel) ([]byte, error) {
    return cxzlib.CompressString(text, level)
}

// UnzlibString 解压为字符串
func UnzlibString(compressedData []byte) (string, error) {
    return cxzlib.DecompressString(compressedData)
}

// ==================== ZLIB 流式压缩API ====================

// ZlibStream 流式压缩数据
func ZlibStream(dst io.Writer, src io.Reader) error {
    return cxzlib.CompressStream(dst, src, types.CompressionLevelDefault)
}

// ZlibStreamWithLevel 流式压缩数据（指定压缩等级）
func ZlibStreamWithLevel(dst io.Writer, src io.Reader, level types.CompressionLevel) error {
    return cxzlib.CompressStream(dst, src, level)
}

// UnzlibStream 流式解压数据
func UnzlibStream(dst io.Writer, src io.Reader) error {
    return cxzlib.DecompressStream(dst, src)
}

```

## 🧪 测试策略

### 测试文件结构
```
internal/cxzlib/
├── zlib_test.go      # 单文件压缩测试
├── unzlib_test.go    # 单文件解压测试
├── memory_test.go    # 内存操作和流式处理测试
└── list_test.go      # 文件列表测试
```

### 测试用例覆盖
1. **功能测试**：基本压缩/解压功能
2. **边界测试**：空数据、大数据、特殊字符
3. **错误测试**：无效输入、文件不存在、权限问题
4. **性能测试**：压缩率、速度基准测试
5. **兼容性测试**：与标准库的兼容性验证
6. **并发测试**：多协程安全性测试

## 📚 文档更新

### README.md 更新内容
1. **支持格式表格**：添加 ZLIB 格式
2. **API 示例**：ZLIB 格式的使用示例
3. **性能对比**：ZLIB 与其他格式的特点和适用场景
4. **迁移指南**：从其他库迁移的建议

### API 文档
1. **函数注释**：完整的参数和返回值说明
2. **使用示例**：每个主要函数的示例代码
3. **最佳实践**：推荐的使用模式和注意事项

## ⚡ 性能优化考虑

### 内存优化
1. **缓冲区复用**：使用 utils 包的缓冲区池
2. **预分配策略**：根据数据大小预分配合适的缓冲区
3. **流式处理**：避免大文件的完整内存加载

### 错误处理
1. **资源清理**：确保所有资源正确释放
2. **错误包装**：提供清晰的错误信息
3. **快速失败**：参数验证前置

## 🔄 兼容性保证

### 向后兼容
1. **API 稳定性**：不修改现有 API 签名
2. **行为一致性**：新格式遵循现有行为模式
3. **配置兼容**：复用现有配置选项

### 标准库兼容
1. **压缩级别映射**：正确映射到标准库的压缩级别
2. **数据格式**：确保与标准库生成的数据兼容
3. **错误处理**：保持与标准库一致的错误类型

## 📋 实现检查清单

### 阶段一检查项
- [ ] types.go 中添加新格式常量
- [ ] 更新格式检测函数
- [ ] 更新支持格式列表
- [ ] 验证配置系统兼容性

### 阶段二检查项（ZLIB）
- [ ] 创建 cxzlib 目录结构
- [ ] 实现 zlib.go 单文件压缩
- [ ] 实现 unzlib.go 单文件解压
- [ ] 实现 memory.go 内存和流式操作
- [ ] 实现 list.go 文件列表功能
- [ ] 编写完整测试用例
- [ ] 测试覆盖率达到 90% 以上

### 阶段三检查项（核心集成）
- [ ] 更新 core/comprx.go 路由逻辑
- [ ] 扩展主包 API 函数
- [ ] 集成测试通过
- [ ] 性能测试基准建立

### 阶段五检查项（测试和文档）
- [ ] 所有测试用例通过
- [ ] 性能测试达到预期
- [ ] README.md 更新完成
- [ ] API 文档完善
- [ ] 示例代码验证

## 🎯 成功标准

1. **功能完整性**：ZLIB 格式完全支持
2. **API 一致性**：与现有格式保持一致的 API 设计
3. **性能表现**：压缩率和速度符合预期
4. **测试覆盖**：测试覆盖率达到 90% 以上
5. **文档完善**：用户可以轻松上手使用
6. **向后兼容**：不破坏现有功能和 API

通过以上详细的实现方案，可以确保 ZLIB 格式的高质量集成，同时保持项目的整体架构一致性和代码质量。
